<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #eee;
    font-family: sans-serif;
  }

  #title {
    position: absolute;
    top: 14px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    z-index: 10;
  }

  #title a {
    color: #eee;
    text-decoration: none;
    border-bottom: 1px solid #666;
  }

  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    z-index: 10;
  }

  #timeLabel {
    text-align: center;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="title"></div>

<div id="ui">
  <div id="timeLabel">t = 0.00 sec</div>
  <input id="timeSlider" type="range">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   URL PARAMS
============================================================ */

const params = new URLSearchParams(window.location.search);
const CSV_URL = params.get("csv") || "modality_agreement_timeseries.csv";
const TITLE = params.get("title");
const LINK  = params.get("link");

const titleDiv = document.getElementById("title");
if (TITLE) {
  const t = decodeURIComponent(TITLE);
  if (LINK) {
    const a = document.createElement("a");
    a.href = decodeURIComponent(LINK);
    a.target = "_blank";
    a.textContent = t;
    titleDiv.appendChild(a);
  } else {
    titleDiv.textContent = t;
  }
}

/* ============================================================
   SCENE
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ============================================================
   GLOBALS
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const labels = {};
const edges = {};
const originalPositions = {};

let rows = [], timeValues = [], pairKeys = [], modalities = [];
let currentTime = 0;
let direction = 1;

const NODE_RADIUS = 0.22;
const EDGE_MIN = 0.015;
const EDGE_MAX = 0.10;

let rotationSpeed = 0;
const ROTATION_MAX = 0.015;

let focused = null;
const targetQuat = new THREE.Quaternion();
const IDENTITY_QUAT = new THREE.Quaternion();
const targetPos = new THREE.Vector3();

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/* ============================================================
   HELPERS
============================================================ */

function modalityDisplayName(full) {
  const i = full.lastIndexOf("_");
  return i === -1 ? full : full.slice(i + 1);
}

function modalityColor(label) {
  label = label.toLowerCase();
  if (label.includes("mpipe")) return new THREE.Color(0xffc0c0);
  if (label.includes("audio")) return new THREE.Color(0x9fb7ff);
  if (label.includes("imu"))   return new THREE.Color(0xc8f0c8);
  return new THREE.Color(0xffffff);
}

function makeLabel(text) {
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  c.width = c.height = 256;
  ctx.font = "48px sans-serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 128, 128);
  const tex = new THREE.CanvasTexture(c);
  const mat = new THREE.SpriteMaterial({ map: tex });
  const s = new THREE.Sprite(mat);
  s.scale.set(1.2, 1.2, 1.2);
  return s;
}

/* ============================================================
   CSV
============================================================ */

fetch(CSV_URL).then(r => r.text()).then(t => {
  const lines = t.trim().split("\n");
  const h = lines[0].split(",");
  rows = lines.slice(1).map(l => {
    const p = l.split(",");
    const o = {};
    h.forEach((k,i) => o[k] = parseFloat(p[i]));
    return o;
  });
  timeValues = rows.map(r => r.time);
  pairKeys = h.filter(k => k !== "time");
  modalities = [...new Set(pairKeys.flatMap(k => k.split("__")))];
  currentTime = timeValues[0];
  init();
});

/* ============================================================
   INIT
============================================================ */

function init() {

  modalities.forEach((name,i) => {
    const phi = Math.acos(1 - 2*(i+0.5)/modalities.length);
    const theta = Math.PI*(1+Math.sqrt(5))*i;
    const pos = new THREE.Vector3(
      2.6*Math.sin(phi)*Math.cos(theta),
      2.6*Math.sin(phi)*Math.sin(theta),
      2.6*Math.cos(phi)
    );

    const node = new THREE.Mesh(
      new THREE.SphereGeometry(NODE_RADIUS, 24, 24),
      new THREE.MeshBasicMaterial({ color: modalityColor(modalityDisplayName(name)) })
    );
    node.position.copy(pos);
    group.add(node);
    nodes[name] = node;
    originalPositions[name] = pos.clone();

    const lbl = makeLabel(modalityDisplayName(name));
    lbl.position.copy(pos).add(new THREE.Vector3(0, 0.6, 0));
    group.add(lbl);
    labels[name] = lbl;
  });

  pairKeys.forEach(k => {
    const geom = new THREE.CylinderGeometry(1,1,1,16,1,true);
    geom.setAttribute("color",
      new THREE.BufferAttribute(new Float32Array(geom.attributes.position.count*3),3)
    );
    const mat = new THREE.MeshBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.2
    });
    const m = new THREE.Mesh(geom, mat);
    group.add(m);
    edges[k] = m;
  });

  setupUI();
  animate();
}

/* ============================================================
   EDGE UPDATE
============================================================ */

function updateEdgeCylinder(edge,p1,p2,c1,c2,thickness){
  const dir = new THREE.Vector3().subVectors(p2,p1);
  const len = dir.length();
  if (len <= 2*NODE_RADIUS) { edge.visible=false; return; }
  dir.normalize();
  const usable = len - 2*NODE_RADIUS;
  edge.position.copy(p1).addScaledVector(dir, NODE_RADIUS + usable/2);
  edge.scale.set(thickness, usable, thickness);
  edge.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);

  const col = edge.geometry.attributes.color.array;
  const pos = edge.geometry.attributes.position.array;
  for (let i=0;i<pos.length;i+=3) {
    const t = pos[i+1] + 0.5;
    const cc = c1.clone().lerp(c2, t);
    col[i] = cc.r; col[i+1] = cc.g; col[i+2] = cc.b;
  }
  edge.geometry.attributes.color.needsUpdate = true;
}

function updateEdges(t){
  let idx=0, best=1e9;
  for(let i=0;i<timeValues.length;i++){
    const d = Math.abs(timeValues[i]-t);
    if (d < best) { best=d; idx=i; }
  }

  document.getElementById("timeLabel").textContent =
    `t = ${(timeValues[idx]/10).toFixed(2)} sec`;

  pairKeys.forEach(k => {
    const v = rows[idx]?.[k];
    const e = edges[k];
    if (!isFinite(v)) { e.visible=false; return; }
    e.visible=true;
    const [a,b] = k.split("__");
    const thick = EDGE_MIN + Math.pow(v,1.3)*(EDGE_MAX-EDGE_MIN);
    updateEdgeCylinder(
      e,
      nodes[a].position,
      nodes[b].position,
      nodes[a].material.color,
      nodes[b].material.color,
      thick
    );
    e.material.opacity = 0.15 + 0.85*v;
  });
}

/* ============================================================
   INTERACTION
============================================================ */

window.addEventListener("click", (e) => {
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(Object.values(nodes));
  if (hits.length) {
    rotationSpeed = 0;

    const obj = hits[0].object;
    const name = Object.keys(nodes).find(k => nodes[k] === obj);
    if (!name) return;

    focused = name;
    const dir = originalPositions[name].clone().normalize();
    targetQuat.copy(
      new THREE.Quaternion().setFromUnitVectors(dir, new THREE.Vector3(0,0,1))
    );
    targetPos.set(0,0,-3.0);
    return;
  }

  // empty space â†’ steady rotation
  focused = null;
  targetQuat.copy(IDENTITY_QUAT);
  targetPos.set(0,0,0);

  const dist = Math.min(Math.sqrt(mouse.x*mouse.x + mouse.y*mouse.y), 1);
  const dir = mouse.x >= 0 ? 1 : -1;
  rotationSpeed = dir * dist * ROTATION_MAX;
});

/* ============================================================
   UI
============================================================ */

function setupUI(){
  const s = document.getElementById("timeSlider");
  s.min = timeValues[0];
  s.max = timeValues.at(-1);
  s.step = (s.max - s.min) / 1000;
  s.value = currentTime;
  s.oninput = () => {
    currentTime = parseFloat(s.value);
    updateEdges(currentTime);
  };
}

/* ============================================================
   ANIMATION LOOP
============================================================ */

let last = performance.now();
function animate(now = performance.now()){
  requestAnimationFrame(animate);
  const dt = (now - last) / 1000;
  last = now;

  currentTime += direction * dt * 10;
  if (currentTime >= timeValues.at(-1)) { currentTime = timeValues.at(-1); direction = -1; }
  if (currentTime <= timeValues[0])     { currentTime = timeValues[0];     direction = 1; }

  document.getElementById("timeSlider").value = currentTime;
  updateEdges(currentTime);

  group.rotation.y += rotationSpeed;
  group.quaternion.slerp(targetQuat, 0.08);
  group.position.lerp(targetPos, 0.08);

  Object.values(labels).forEach(l => {
    const d = camera.position.distanceTo(l.position);
    const s = THREE.MathUtils.clamp(6/d, 0.6, 1.4);
    l.scale.set(s,s,s);
  });

  renderer.render(scene, camera);
}
</script>

</body>
</html>
