<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #eee;
    font-family: sans-serif;
  }

  #title {
    position: absolute;
    top: 14px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    z-index: 10;
  }

  #title a {
    color: #eee;
    text-decoration: none;
    border-bottom: 1px solid #666;
  }

  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    z-index: 10;
  }

  #timeLabel {
    text-align: center;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="title"></div>

<div id="ui">
  <div id="timeLabel">t = 0.00 sec</div>
  <input id="timeSlider" type="range">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   URL params
============================================================ */

const params = new URLSearchParams(window.location.search);
const CSV_URL = params.get("csv") || "modality_agreement_timeseries.csv";
const TITLE = params.get("title");
const LINK  = params.get("link");

const titleDiv = document.getElementById("title");
if (TITLE) {
  if (LINK) {
    const a = document.createElement("a");
    a.href = decodeURIComponent(LINK);
    a.target = "_blank";
    a.textContent = decodeURIComponent(TITLE);
    titleDiv.appendChild(a);
  } else {
    titleDiv.textContent = decodeURIComponent(TITLE);
  }
}

/* ============================================================
   Scene
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0,7);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ============================================================
   Globals
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const labels = {};
const edges = {};
const originalPositions = {};

let rows=[], timeValues=[], pairKeys=[], modalities=[];
let currentTime = 0;
let isPlaying = true;
let direction = 1;

let focused = null;
let rotationSpeed = 0;   // <-- STEADY ROTATION SPEED

const ROTATION_MAX = 0.015;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/* ============================================================
   Helpers
============================================================ */

function modalityDisplayName(full) {
  const i = full.lastIndexOf("_");
  return i === -1 ? full : full.slice(i+1);
}

function modalityColor(label) {
  label = label.toLowerCase();
  if (label.includes("mpipe")) return new THREE.Color(0xffc0c0);
  if (label.includes("audio")) return new THREE.Color(0x9fb7ff);
  if (label.includes("imu"))   return new THREE.Color(0xc8f0c8);
  return new THREE.Color(0xffffff);
}

function makeLabel(text) {
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  c.width = c.height = 256;
  ctx.font = "48px sans-serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text,128,128);
  const tex = new THREE.CanvasTexture(c);
  const mat = new THREE.SpriteMaterial({ map: tex });
  const s = new THREE.Sprite(mat);
  s.scale.set(1.2,1.2,1.2);
  return s;
}

/* ============================================================
   CSV
============================================================ */

fetch(CSV_URL).then(r=>r.text()).then(t=>{
  const lines=t.trim().split("\n");
  const h=lines[0].split(",");
  rows=lines.slice(1).map(l=>{
    const p=l.split(",");
    const o={};
    h.forEach((k,i)=>o[k]=parseFloat(p[i]));
    return o;
  });
  timeValues=rows.map(r=>r.time);
  pairKeys=h.filter(k=>k!=="time");
  modalities=[...new Set(pairKeys.flatMap(k=>k.split("__")))];
  currentTime=timeValues[0];
  init();
});

/* ============================================================
   Init
============================================================ */

function init(){
  modalities.forEach((name,i)=>{
    const phi=Math.acos(1-2*(i+0.5)/modalities.length);
    const theta=Math.PI*(1+Math.sqrt(5))*i;
    const pos=new THREE.Vector3(
      2.6*Math.sin(phi)*Math.cos(theta),
      2.6*Math.sin(phi)*Math.sin(theta),
      2.6*Math.cos(phi)
    );

    const node=new THREE.Mesh(
      new THREE.SphereGeometry(0.22,24,24),
      new THREE.MeshBasicMaterial({ color: modalityColor(modalityDisplayName(name)) })
    );
    node.position.copy(pos);
    group.add(node);
    nodes[name]=node;
    originalPositions[name]=pos.clone();

    const lbl=makeLabel(modalityDisplayName(name));
    lbl.position.copy(pos).add(new THREE.Vector3(0,0.6,0));
    group.add(lbl);
    labels[name]=lbl;
  });

  animate();
}

/* ============================================================
   Click handling
============================================================ */

window.addEventListener("click", (e)=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);

  const hits=raycaster.intersectObjects(Object.values(nodes));
  if(hits.length){
    // click node → stop rotation
    rotationSpeed = 0;
    focused = null;
    return;
  }

  // click empty → start steady rotation
  const dist=Math.min(Math.sqrt(mouse.x*mouse.x+mouse.y*mouse.y),1);
  const dir=mouse.x>=0?1:-1;
  rotationSpeed = dir * dist * ROTATION_MAX;
});

/* ============================================================
   Animation
============================================================ */

let last=performance.now();
function animate(now=performance.now()){
  requestAnimationFrame(animate);
  const dt=(now-last)/1000; last=now;

  // timeline autoplay
  currentTime += direction*dt*10;
  if(currentTime>=timeValues.at(-1)){currentTime=timeValues.at(-1);direction=-1;}
  if(currentTime<=timeValues[0]){currentTime=timeValues[0];direction=1;}

  // STEADY rotation
  group.rotation.y += rotationSpeed;

  Object.values(labels).forEach(l=>{
    const d=camera.position.distanceTo(l.position);
    const s=THREE.MathUtils.clamp(6/d,0.6,1.4);
    l.scale.set(s,s,s);
  });

  renderer.render(scene,camera);
}
</script>

</body>
</html>
